# Implementation Plan: Web App to Manage Albums

**Branch**: `001-system-design` | **Date**: September 16, 2025 | **Spec**: [here](specs/spec.md)
**Input**: Feature specification from `/specs/spec.md`

## Summary
A simple web app for users to manage photo albums and images, with CRUD operations for both, deployed on AWS. Users are authenticated via Cognito, and all images are stored in S3. The backend is serverless (AWS Lambda, Python), and the frontend is a basic SPA generated by the backend. The system enforces per-user storage and album limits, and ties all data to the user's Cognito ID.

## Technical Context
- **Language/Version**: Python 3.13 (backend), React/JavaScript (frontend)
- **Primary Dependencies**: AWS Lambda, AWS Cognito, AWS S3, AWS CloudWatch 
- **Storage**: AWS S3 (images), DynamoDB (metadata/user quota)
- **Testing**: LocalStack + pytest (backend), manual or browser-based (frontend)
- **Target Platform**: AWS Lambda (backend), browser (frontend)
- **Project Type**: Web (frontend + backend)
- **Performance Goals**: Fast user experience, low cost, minimal cold start latency
- **Constraints**: <200ms p95 for API, <500MB/user storage, 10 albums/user, 10MB/image
- **Scale/Scope**: Demo scale (single-digit users, not production but publicly accessible)

## Constitution Check
- No major violations. All requirements are clear, testable, and business-focused. Implementation details are noted but not excessive.

## Technical Considerations
### Error Handling and Logging
- The Lambda functions will include error handling to catch and log failures, especially for S3 operations. Errors will be logged to CloudWatch for monitoring and debugging.
- Logging for S3 upload/download actions will also be implemented through CloudWatch.

---

### Security
**1. Input Validation and Sanitization**
- Set length limits (e.g., max 100 chars for names).
- Allow only safe characters (letters, numbers, spaces, dashes, underscores).
- Reject or sanitize anything else.
- Never use user input directly in S3 keys without checking it.

**2. CORS (Cross-Origin Resource Sharing)**
- The API Gateway will be configured to allow CORS from the frontend domain to enable SPA interactions. On the API Gateway, set CORS headers:
    - `Access-Control-Allow-Origin: *` (for public APIs) or your frontend’s domain (for more security)
    - `Access-Control-Allow-Methods: GET, POST, PUT, DELETE`
    - `Access-Control-Allow-Headers: Content-Type, Authorization`

**3. HTTPS and API Gateway**
- API Gateway will enforce HTTPS for all requests.

**4. S3 Bucket Policies**
- The bucket can only be accessed by the Lambda functions and not publicly. Use bucket policies to restrict access.

**5. Image Validation**
- To prevent malicious files, the following checks will be implemented:
  - Only allow standard image formats (e.g., JPEG, PNG, GIF).
  - Reject SVG uploads, or strictly sanitize them.
  - Always serve images with the correct Content-Type header.
  - Do not process or display images using libraries with known vulnerabilities.
  - If possible, scan images for malware (Lambda with ClamAV).

---

### Deployment
- The project would mostly like be deployed manually for simplicity and due to its small scale.
- For secrets, use AWS Secrets Manager or environment variables in Lambda.

---

### Testing 
- Backend unit tests will be written using pytest
- Integration tests can be run locally with LocalStack to simulate AWS services, or even another test run after deployment to AWS
- Smoke test will be done manually, or, if applicable, with Playwright.

---

### Frontend SPA
- The frontend will be a simple SPA generated by the backend which use React + JavaScript and hash-based routing.

---

### Scalability & Limits
- We can track the total storage used per user by logging it into DynamoDB  
- Timeout with Lambda (max 15 mins) is unlikely for this use case. However, we can set a lower timeout (e.g., 30s) to avoid long-running requests.
- Rate limits on API Gateway can be configured to prevent abuse.

---

### Documentation
- API docs in OpenAPI format will be created to act as a contract and reference for AI agents.
- A simple README will be mocked up, but the detailed version might only be available in the later stages.



## Project Structure

### Documentation
```
specs/
├── spec.md              # Initial specification
├── plan.md              # This file
├── data-model.md        # Phase 1 output
├── API_contracts.md     # Phase 1 output
├── quickstart.md        # Phase 2 output (may be minimal, or not available)
└── tasks.md             # Phase 2 output
```

### Source Code (repository root)
```
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/
```

**Structure Decision**: Web application (frontend + backend)

---

### NoSQL Database Schema (DynamoDB)
- **Table name**: `AlbumsApp`

  - **Primary Key**:
    - **Partition Key**: `user_id` (string)
    - **Sort Key**: `type` (string) - values: 
      - `album#<album_id>` - for albums' metadata
      - `image#<image_id>` - for images' metadata
      - `quota` - for user storage quota and albums count

  - **Attributes** - all of these would be Map attributes under the respective items:
    - For albums: `album_id`, `name`, `description`, `image_count`, `created_at`, `updated_at`
    - For images: `image_id`, `album_id`, `name`, `description`, `s3_key`, `size_bytes`, `content_type`, `created_at`, `updated_at`
    - For quota: `total_storage_bytes`, `album_count`


## Phase 0: Outline & Research
- Confirm all technical unknowns are resolved (e.g., Cognito integration, S3 access patterns, Lambda deployment best practices).
- Research best practices for FastAPI on Lambda, S3 security, and SPA generation from backend.

## Phase 1: Design & Contracts
- Define data models for User, Album, Image (fields, relationships, validation).
- Design REST API endpoints for all CRUD operations and authentication.
- Generate OpenAPI schema and contract tests for each endpoint.
- Extract test scenarios from user stories and edge cases.

## Phase 2: Task Planning Approach
- Tasks will be generated from the design docs (data model, contracts, quickstart).
- Each contract and entity will have a corresponding implementation and test task.
- TDD and dependency order will be followed (models → services → API → UI).

## Complexity Tracking
| Consideration | Why | Alternative |
|---------------|-----|-------------|
| Omitting FastAPI | FastAPI requires an adapter (such as Magnum) to work with Lambda. The same is applied to Flask. | Use basic Python for AWS Lambda's basis of event-driven. |
| Using DynamoDB | DynamoDB is a fully managed NoSQL database, has a free tier (important), and can be used to store metadata and user quota. | RDS requires upfront cost. Storing metadata in a JSON file in S3 is possible but less efficient. |
| Using S3 + CloudFront for frontend | S3 + CloudFront is more complex than serving the frontend directly through Lambda, but it is a cost-effective way to host static websites. | More complex setups (e.g., Amplify) or exposing the S3 bucket if served directly or using only generated HTML from backend. |
| Using React and JavaScript | As we have moved to S3 static hosting, we can afford to use React for a modern SPA experience. | Vanilla JS or a simpler framework (e.g., Vue) could be used, but React is widely known and has good community support. |

## Progress Tracking
**Phase Status**:
- [x] Phase 0: Research complete
- [ ] Phase 1: Design complete
- [ ] Phase 2: Task planning complete
- [ ] Phase 3: Tasks generated
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [ ] Initial Constitution Check: PASS
- [ ] Post-Design Constitution Check: PASS
- [ ] All NEEDS CLARIFICATION resolved
- [ ] Complexity deviations documented

---
